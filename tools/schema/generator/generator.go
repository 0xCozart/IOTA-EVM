// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

package generator

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"sort"
	"strings"
)

const (
	AccessChain         = "chain"
	AccessCreator       = "creator"
	AccessSelf          = "self"
	AliasThis           = "this"
	InitFunc            = "Init"
	KindFunc            = "Func"
	KindView            = "View"
	PropImmutable       = "Immutable"
	PropMutable         = "Mutable"
	SpecialFuncInit     = "funcInit"
	SpecialFuncSetOwner = "setOwner"
	SpecialViewGetOwner = "getOwner"
)

var (
	ModuleCwd  = "???"
	ModuleName = "???"
	ModulePath = "???"
)

//nolint:unused
var (
	camelRegExp  = regexp.MustCompile(`_[a-z]`)
	snakeRegExp  = regexp.MustCompile(`[a-z0-9][A-Z]`)
	snakeRegExp2 = regexp.MustCompile(`[A-Z][A-Z]+[a-z]`)
)

type Generator struct {
	s    *Schema
	file *os.File
}

func (g *Generator) close() {
	_ = g.file.Close()
}

func (g *Generator) create(path string) (err error) {
	g.file, err = os.Create(path)
	return err
}

func (g *Generator) exists(path string) (err error) {
	_, err = os.Stat(path)
	return err
}

func (g *Generator) formatter(on bool) {
	if on {
		g.printf("\n// @formatter:%s\n", "on")
		return
	}
	g.printf("// @formatter:%s\n\n", "off")
}

func (g *Generator) GenerateGoTests() error {
	err := os.MkdirAll("test", 0o755)
	if err != nil {
		return err
	}

	// do not overwrite existing file
	name := strings.ToLower(g.s.Name)
	filename := "test/" + name + "_test.go"
	err = g.exists(filename)
	if err == nil {
		return nil
	}

	err = g.create(filename)
	if err != nil {
		return err
	}
	defer g.close()

	module := ModuleName + strings.ReplaceAll(ModuleCwd[len(ModulePath):], "\\", "/")
	g.println("package test")
	g.println()
	g.println("import (")
	g.println("\t\"testing\"")
	g.println()
	g.printf("\t\"%s/go/%s\"\n", module, g.s.Name)
	g.println("\t\"github.com/iotaledger/wasp/packages/vm/wasmsolo\"")
	g.println("\t\"github.com/stretchr/testify/require\"")
	g.println(")")
	g.println()
	g.println("func TestDeploy(t *testing.T) {")
	g.printf("\tctx := wasmsolo.NewSoloContext(t, %s.ScName, %s.OnLoad)\n", name, name)
	g.printf("\trequire.NoError(t, ctx.ContractExists(%s.ScName))\n", name)
	g.println("}")

	return nil
}

func (g *Generator) open(path string) (err error) {
	g.file, err = os.Open(path)
	return err
}

//func (g *Generator) print(a ...interface{}) {
//	_, _ = fmt.Fprint(g.file, a...)
//}

func (g *Generator) printf(format string, a ...interface{}) {
	_, _ = fmt.Fprintf(g.file, format, a...)
}

func (g *Generator) println(a ...interface{}) {
	_, _ = fmt.Fprintln(g.file, a...)
}

func (g *Generator) scanExistingCode(funcRegexp *regexp.Regexp) ([]string, StringMap, error) {
	defer g.close()
	existing := make(StringMap)
	lines := make([]string, 0)
	scanner := bufio.NewScanner(g.file)
	for scanner.Scan() {
		line := scanner.Text()
		matches := funcRegexp.FindStringSubmatch(line)
		if matches != nil {
			existing[matches[1]] = line
		}
		lines = append(lines, line)
	}
	err := scanner.Err()
	if err != nil {
		return nil, nil, err
	}
	return lines, existing, nil
}

func calculatePadding(fields []*Field, types StringMap, snakeName bool) (nameLen, typeLen int) {
	for _, param := range fields {
		fldName := param.Name
		if snakeName {
			fldName = snake(fldName)
		}
		if nameLen < len(fldName) {
			nameLen = len(fldName)
		}
		fldType := param.Type
		if types != nil {
			fldType = types[fldType]
		}
		if typeLen < len(fldType) {
			typeLen = len(fldType)
		}
	}
	return
}

// convert lowercase snake case to camel case
//nolint:deadcode,unused
func camel(name string) string {
	return camelRegExp.ReplaceAllStringFunc(name, func(sub string) string {
		return strings.ToUpper(sub[1:])
	})
}

// capitalize first letter
func capitalize(name string) string {
	return upper(name[:1]) + name[1:]
}

// TODO take copyright from schema?
func copyright(noChange bool) string {
	text := "// Copyright 2020 IOTA Stiftung\n" +
		"// SPDX-License-Identifier: Apache-2.0\n"
	if noChange {
		text += "\n// (Re-)generated by schema tool\n" +
			"// >>>> DO NOT CHANGE THIS FILE! <<<<\n" +
			"// Change the json schema instead\n"
	}
	return text
}

// convert to lower case
func lower(name string) string {
	return strings.ToLower(name)
}

func FindModulePath() error {
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	// we're going to walk up the path, make sure to restore
	ModuleCwd = cwd
	defer func() {
		_ = os.Chdir(ModuleCwd)
	}()

	file, err := os.Open("go.mod")
	for err != nil {
		err = os.Chdir("..")
		if err != nil {
			return fmt.Errorf("cannot find go.mod in cwd path")
		}
		prev := cwd
		cwd, err = os.Getwd()
		if err != nil {
			return err
		}
		if cwd == prev {
			// e.g. Chdir("..") gets us in a loop at Linux root
			return fmt.Errorf("cannot find go.mod in cwd path")
		}
		file, err = os.Open("go.mod")
	}

	// now file is the go.mod and cwd holds the path
	defer func() {
		_ = file.Close()
	}()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "module ") {
			ModuleName = strings.TrimSpace(line[len("module"):])
			ModulePath = cwd
			return nil
		}
	}

	return fmt.Errorf("cannot find module definition in go.mod")
}

// pad to specified size with spaces
func pad(name string, size int) string {
	for i := len(name); i < size; i++ {
		name += " "
	}
	return name
}

// convert camel case to lower case snake case
func snake(name string) string {
	name = snakeRegExp.ReplaceAllStringFunc(name, func(sub string) string {
		return sub[:1] + "_" + sub[1:]
	})
	name = snakeRegExp2.ReplaceAllStringFunc(name, func(sub string) string {
		n := len(sub)
		return sub[:n-2] + "_" + sub[n-2:]
	})
	return lower(name)
}

// uncapitalize first letter
func uncapitalize(name string) string {
	return lower(name[:1]) + name[1:]
}

// convert to upper case
func upper(name string) string {
	return strings.ToUpper(name)
}

func sortedFields(dict FieldMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func sortedKeys(dict StringMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func sortedFuncDescs(dict FuncDefMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}

func sortedMaps(dict StringMapMap) []string {
	keys := make([]string, 0)
	for key := range dict {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	return keys
}
