// Copyright 2020 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0

// (Re-)generated by schema tool
// >>>> DO NOT CHANGE THIS FILE! <<<<
// Change the json schema instead

import * as wasmlib from "../wasmlib"
import * as sc from "./index";

export function on_call(index: i32): void {
    return wasmlib.onCall(index);
}

export function on_load(): void {
    let exports = new wasmlib.ScExports();
    exports.addFunc(sc.FuncCallOnChain, funcCallOnChainThunk);
    exports.addFunc(sc.FuncCheckContextFromFullEP, funcCheckContextFromFullEPThunk);
    exports.addFunc(sc.FuncDoNothing, funcDoNothingThunk);
    exports.addFunc(sc.FuncGetMintedSupply, funcGetMintedSupplyThunk);
    exports.addFunc(sc.FuncIncCounter, funcIncCounterThunk);
    exports.addFunc(sc.FuncInit, funcInitThunk);
    exports.addFunc(sc.FuncPassTypesFull, funcPassTypesFullThunk);
    exports.addFunc(sc.FuncRunRecursion, funcRunRecursionThunk);
    exports.addFunc(sc.FuncSendToAddress, funcSendToAddressThunk);
    exports.addFunc(sc.FuncSetInt, funcSetIntThunk);
    exports.addFunc(sc.FuncSpawn, funcSpawnThunk);
    exports.addFunc(sc.FuncTestBlockContext1, funcTestBlockContext1Thunk);
    exports.addFunc(sc.FuncTestBlockContext2, funcTestBlockContext2Thunk);
    exports.addFunc(sc.FuncTestCallPanicFullEP, funcTestCallPanicFullEPThunk);
    exports.addFunc(sc.FuncTestCallPanicViewEPFromFull, funcTestCallPanicViewEPFromFullThunk);
    exports.addFunc(sc.FuncTestChainOwnerIDFull, funcTestChainOwnerIDFullThunk);
    exports.addFunc(sc.FuncTestEventLogDeploy, funcTestEventLogDeployThunk);
    exports.addFunc(sc.FuncTestEventLogEventData, funcTestEventLogEventDataThunk);
    exports.addFunc(sc.FuncTestEventLogGenericData, funcTestEventLogGenericDataThunk);
    exports.addFunc(sc.FuncTestPanicFullEP, funcTestPanicFullEPThunk);
    exports.addFunc(sc.FuncWithdrawToChain, funcWithdrawToChainThunk);
    exports.addView(sc.ViewCheckContextFromViewEP, viewCheckContextFromViewEPThunk);
    exports.addView(sc.ViewFibonacci, viewFibonacciThunk);
    exports.addView(sc.ViewGetCounter, viewGetCounterThunk);
    exports.addView(sc.ViewGetInt, viewGetIntThunk);
    exports.addView(sc.ViewGetStringValue, viewGetStringValueThunk);
    exports.addView(sc.ViewJustView, viewJustViewThunk);
    exports.addView(sc.ViewPassTypesView, viewPassTypesViewThunk);
    exports.addView(sc.ViewTestCallPanicViewEPFromView, viewTestCallPanicViewEPFromViewThunk);
    exports.addView(sc.ViewTestChainOwnerIDView, viewTestChainOwnerIDViewThunk);
    exports.addView(sc.ViewTestPanicViewEP, viewTestPanicViewEPThunk);
    exports.addView(sc.ViewTestSandboxCall, viewTestSandboxCallThunk);

    for (let i = 0; i < sc.keyMap.length; i++) {
        sc.idxMap[i] = wasmlib.Key32.fromString(sc.keyMap[i]);
    }
}

export class CallOnChainContext {
    params: sc.ImmutableCallOnChainParams = new sc.ImmutableCallOnChainParams();
    results: sc.MutableCallOnChainResults = new sc.MutableCallOnChainResults();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcCallOnChainThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcCallOnChain");
    let f = new CallOnChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.funcCallOnChain(ctx, f);
    ctx.log("testcore.funcCallOnChain ok");
}

export class CheckContextFromFullEPContext {
    params: sc.ImmutableCheckContextFromFullEPParams = new sc.ImmutableCheckContextFromFullEPParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcCheckContextFromFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcCheckContextFromFullEP");
    let f = new CheckContextFromFullEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.caller().exists(), "missing mandatory caller")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID")
    ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator")
    sc.funcCheckContextFromFullEP(ctx, f);
    ctx.log("testcore.funcCheckContextFromFullEP ok");
}

export class DoNothingContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcDoNothingThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcDoNothing");
    let f = new DoNothingContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcDoNothing(ctx, f);
    ctx.log("testcore.funcDoNothing ok");
}

export class GetMintedSupplyContext {
    results: sc.MutableGetMintedSupplyResults = new sc.MutableGetMintedSupplyResults();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcGetMintedSupplyThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcGetMintedSupply");
    let f = new GetMintedSupplyContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcGetMintedSupply(ctx, f);
    ctx.log("testcore.funcGetMintedSupply ok");
}

export class IncCounterContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcIncCounterThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcIncCounter");
    let f = new IncCounterContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcIncCounter(ctx, f);
    ctx.log("testcore.funcIncCounter ok");
}

export class InitContext {
    params: sc.ImmutableInitParams = new sc.ImmutableInitParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcInitThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcInit");
    let f = new InitContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcInit(ctx, f);
    ctx.log("testcore.funcInit ok");
}

export class PassTypesFullContext {
    params: sc.ImmutablePassTypesFullParams = new sc.ImmutablePassTypesFullParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcPassTypesFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcPassTypesFull");
    let f = new PassTypesFullContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.contractID().exists(), "missing mandatory contractID")
    ctx.require(f.params.hash().exists(), "missing mandatory hash")
    ctx.require(f.params.hname().exists(), "missing mandatory hname")
    ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero")
    ctx.require(f.params.int64().exists(), "missing mandatory int64")
    ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero")
    ctx.require(f.params.string().exists(), "missing mandatory string")
    ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero")
    sc.funcPassTypesFull(ctx, f);
    ctx.log("testcore.funcPassTypesFull ok");
}

export class RunRecursionContext {
    params: sc.ImmutableRunRecursionParams = new sc.ImmutableRunRecursionParams();
    results: sc.MutableRunRecursionResults = new sc.MutableRunRecursionResults();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcRunRecursionThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcRunRecursion");
    let f = new RunRecursionContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.funcRunRecursion(ctx, f);
    ctx.log("testcore.funcRunRecursion ok");
}

export class SendToAddressContext {
    params: sc.ImmutableSendToAddressParams = new sc.ImmutableSendToAddressParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcSendToAddressThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSendToAddress");
    ctx.require(ctx.caller().equals(ctx.contractCreator()), "no permission");

    let f = new SendToAddressContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    sc.funcSendToAddress(ctx, f);
    ctx.log("testcore.funcSendToAddress ok");
}

export class SetIntContext {
    params: sc.ImmutableSetIntParams = new sc.ImmutableSetIntParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcSetIntThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSetInt");
    let f = new SetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    ctx.require(f.params.name().exists(), "missing mandatory name")
    sc.funcSetInt(ctx, f);
    ctx.log("testcore.funcSetInt ok");
}

export class SpawnContext {
    params: sc.ImmutableSpawnParams = new sc.ImmutableSpawnParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcSpawnThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcSpawn");
    let f = new SpawnContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.progHash().exists(), "missing mandatory progHash")
    sc.funcSpawn(ctx, f);
    ctx.log("testcore.funcSpawn ok");
}

export class TestBlockContext1Context {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestBlockContext1Thunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestBlockContext1");
    let f = new TestBlockContext1Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestBlockContext1(ctx, f);
    ctx.log("testcore.funcTestBlockContext1 ok");
}

export class TestBlockContext2Context {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestBlockContext2Thunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestBlockContext2");
    let f = new TestBlockContext2Context();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestBlockContext2(ctx, f);
    ctx.log("testcore.funcTestBlockContext2 ok");
}

export class TestCallPanicFullEPContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestCallPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestCallPanicFullEP");
    let f = new TestCallPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestCallPanicFullEP(ctx, f);
    ctx.log("testcore.funcTestCallPanicFullEP ok");
}

export class TestCallPanicViewEPFromFullContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestCallPanicViewEPFromFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestCallPanicViewEPFromFull");
    let f = new TestCallPanicViewEPFromFullContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestCallPanicViewEPFromFull(ctx, f);
    ctx.log("testcore.funcTestCallPanicViewEPFromFull ok");
}

export class TestChainOwnerIDFullContext {
    results: sc.MutableTestChainOwnerIDFullResults = new sc.MutableTestChainOwnerIDFullResults();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestChainOwnerIDFullThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestChainOwnerIDFull");
    let f = new TestChainOwnerIDFullContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestChainOwnerIDFull(ctx, f);
    ctx.log("testcore.funcTestChainOwnerIDFull ok");
}

export class TestEventLogDeployContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestEventLogDeployThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogDeploy");
    let f = new TestEventLogDeployContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestEventLogDeploy(ctx, f);
    ctx.log("testcore.funcTestEventLogDeploy ok");
}

export class TestEventLogEventDataContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestEventLogEventDataThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogEventData");
    let f = new TestEventLogEventDataContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestEventLogEventData(ctx, f);
    ctx.log("testcore.funcTestEventLogEventData ok");
}

export class TestEventLogGenericDataContext {
    params: sc.ImmutableTestEventLogGenericDataParams = new sc.ImmutableTestEventLogGenericDataParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestEventLogGenericDataThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestEventLogGenericData");
    let f = new TestEventLogGenericDataContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.counter().exists(), "missing mandatory counter")
    sc.funcTestEventLogGenericData(ctx, f);
    ctx.log("testcore.funcTestEventLogGenericData ok");
}

export class TestPanicFullEPContext {
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcTestPanicFullEPThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcTestPanicFullEP");
    let f = new TestPanicFullEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.funcTestPanicFullEP(ctx, f);
    ctx.log("testcore.funcTestPanicFullEP ok");
}

export class WithdrawToChainContext {
    params: sc.ImmutableWithdrawToChainParams = new sc.ImmutableWithdrawToChainParams();
    state: sc.MutableTestCoreState = new sc.MutableTestCoreState();
}

function funcWithdrawToChainThunk(ctx: wasmlib.ScFuncContext): void {
    ctx.log("testcore.funcWithdrawToChain");
    let f = new WithdrawToChainContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    sc.funcWithdrawToChain(ctx, f);
    ctx.log("testcore.funcWithdrawToChain ok");
}

export class CheckContextFromViewEPContext {
    params: sc.ImmutableCheckContextFromViewEPParams = new sc.ImmutableCheckContextFromViewEPParams();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewCheckContextFromViewEPThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewCheckContextFromViewEP");
    let f = new CheckContextFromViewEPContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.chainOwnerID().exists(), "missing mandatory chainOwnerID")
    ctx.require(f.params.contractCreator().exists(), "missing mandatory contractCreator")
    sc.viewCheckContextFromViewEP(ctx, f);
    ctx.log("testcore.viewCheckContextFromViewEP ok");
}

export class FibonacciContext {
    params: sc.ImmutableFibonacciParams = new sc.ImmutableFibonacciParams();
    results: sc.MutableFibonacciResults = new sc.MutableFibonacciResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewFibonacciThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewFibonacci");
    let f = new FibonacciContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.intValue().exists(), "missing mandatory intValue")
    sc.viewFibonacci(ctx, f);
    ctx.log("testcore.viewFibonacci ok");
}

export class GetCounterContext {
    results: sc.MutableGetCounterResults = new sc.MutableGetCounterResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewGetCounterThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetCounter");
    let f = new GetCounterContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewGetCounter(ctx, f);
    ctx.log("testcore.viewGetCounter ok");
}

export class GetIntContext {
    params: sc.ImmutableGetIntParams = new sc.ImmutableGetIntParams();
    results: sc.MutableGetIntResults = new sc.MutableGetIntResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewGetIntThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetInt");
    let f = new GetIntContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.name().exists(), "missing mandatory name")
    sc.viewGetInt(ctx, f);
    ctx.log("testcore.viewGetInt ok");
}

export class GetStringValueContext {
    params: sc.ImmutableGetStringValueParams = new sc.ImmutableGetStringValueParams();
    results: sc.MutableGetStringValueResults = new sc.MutableGetStringValueResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewGetStringValueThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewGetStringValue");
    let f = new GetStringValueContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.varName().exists(), "missing mandatory varName")
    sc.viewGetStringValue(ctx, f);
    ctx.log("testcore.viewGetStringValue ok");
}

export class JustViewContext {
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewJustViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewJustView");
    let f = new JustViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewJustView(ctx, f);
    ctx.log("testcore.viewJustView ok");
}

export class PassTypesViewContext {
    params: sc.ImmutablePassTypesViewParams = new sc.ImmutablePassTypesViewParams();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewPassTypesViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewPassTypesView");
    let f = new PassTypesViewContext();
    f.params.mapID = wasmlib.OBJ_ID_PARAMS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    ctx.require(f.params.address().exists(), "missing mandatory address")
    ctx.require(f.params.agentID().exists(), "missing mandatory agentID")
    ctx.require(f.params.chainID().exists(), "missing mandatory chainID")
    ctx.require(f.params.contractID().exists(), "missing mandatory contractID")
    ctx.require(f.params.hash().exists(), "missing mandatory hash")
    ctx.require(f.params.hname().exists(), "missing mandatory hname")
    ctx.require(f.params.hnameZero().exists(), "missing mandatory hnameZero")
    ctx.require(f.params.int64().exists(), "missing mandatory int64")
    ctx.require(f.params.int64Zero().exists(), "missing mandatory int64Zero")
    ctx.require(f.params.string().exists(), "missing mandatory string")
    ctx.require(f.params.stringZero().exists(), "missing mandatory stringZero")
    sc.viewPassTypesView(ctx, f);
    ctx.log("testcore.viewPassTypesView ok");
}

export class TestCallPanicViewEPFromViewContext {
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewTestCallPanicViewEPFromViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestCallPanicViewEPFromView");
    let f = new TestCallPanicViewEPFromViewContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestCallPanicViewEPFromView(ctx, f);
    ctx.log("testcore.viewTestCallPanicViewEPFromView ok");
}

export class TestChainOwnerIDViewContext {
    results: sc.MutableTestChainOwnerIDViewResults = new sc.MutableTestChainOwnerIDViewResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewTestChainOwnerIDViewThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestChainOwnerIDView");
    let f = new TestChainOwnerIDViewContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestChainOwnerIDView(ctx, f);
    ctx.log("testcore.viewTestChainOwnerIDView ok");
}

export class TestPanicViewEPContext {
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewTestPanicViewEPThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestPanicViewEP");
    let f = new TestPanicViewEPContext();
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestPanicViewEP(ctx, f);
    ctx.log("testcore.viewTestPanicViewEP ok");
}

export class TestSandboxCallContext {
    results: sc.MutableTestSandboxCallResults = new sc.MutableTestSandboxCallResults();
    state: sc.ImmutableTestCoreState = new sc.ImmutableTestCoreState();
}

function viewTestSandboxCallThunk(ctx: wasmlib.ScViewContext): void {
    ctx.log("testcore.viewTestSandboxCall");
    let f = new TestSandboxCallContext();
    f.results.mapID = wasmlib.OBJ_ID_RESULTS;
    f.state.mapID = wasmlib.OBJ_ID_STATE;
    sc.viewTestSandboxCall(ctx, f);
    ctx.log("testcore.viewTestSandboxCall ok");
}
