package dkg

import (
	"bytes"
	"encoding"
	"io"

	"github.com/iotaledger/wasp/packages/util"
	"go.dedis.ch/kyber/v3"
	"go.dedis.ch/kyber/v3/share"
	rabin_dkg "go.dedis.ch/kyber/v3/share/dkg/rabin"
	rabin_vss "go.dedis.ch/kyber/v3/share/vss/rabin"
)

const (
	rabinDealMsgType          byte = 1
	rabinResponseMsgType      byte = 2
	rabinJustificationMsgType byte = 3
	rabinSecretCommitsMsgType byte = 4
)

type msgByteCoder interface {
	MsgType() byte
	Write(io.Writer) error
	Read(io.Reader) error
}

//
// This file contains message types, exchanged between the DKG nodes
// via the peering network.
//

//
//
//
type rabinDealMsg struct {
	deal *rabin_dkg.Deal
}

func (m *rabinDealMsg) MsgType() byte {
	return rabinDealMsgType
}
func (m *rabinDealMsg) Write(w io.Writer) error {
	var err error
	if err = util.WriteUint32(w, m.deal.Index); err != nil {
		return err
	}
	if err = writeMarshaled(w, m.deal.Deal.DHKey); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, m.deal.Deal.Signature); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, m.deal.Deal.Nonce); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, m.deal.Deal.Cipher); err != nil {
		return err
	}
	return nil
}
func (m *rabinDealMsg) Read(r io.Reader) error {
	var err error
	if err = util.ReadUint32(r, &m.deal.Index); err != nil {
		return err
	}
	if err = readMarshaled(r, m.deal.Deal.DHKey); err != nil {
		return err
	}
	if m.deal.Deal.Signature, err = util.ReadBytes16(r); err != nil {
		return err
	}
	if m.deal.Deal.Nonce, err = util.ReadBytes16(r); err != nil {
		return err
	}
	if m.deal.Deal.Cipher, err = util.ReadBytes16(r); err != nil {
		return err
	}
	return nil
}
func (m *rabinDealMsg) fromBytes(buf []byte, group kyber.Group) error {
	m.deal = &rabin_dkg.Deal{
		Deal: &rabin_vss.EncryptedDeal{
			DHKey: group.Point(),
		},
	}
	rdr := bytes.NewReader(buf)
	return m.Read(rdr)
}

//
//
//
type rabinResponseMsg struct {
	response *rabin_dkg.Response
}

func (m *rabinResponseMsg) MsgType() byte {
	return rabinResponseMsgType
}
func (m *rabinResponseMsg) Write(w io.Writer) error {
	var err error
	if err = util.WriteUint32(w, m.response.Index); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, m.response.Response.SessionID); err != nil {
		return err
	}
	if err = util.WriteUint32(w, m.response.Response.Index); err != nil {
		return err
	}
	if err = util.WriteBoolByte(w, m.response.Response.Approved); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, m.response.Response.Signature); err != nil {
		return err
	}
	return nil
}
func (m *rabinResponseMsg) Read(r io.Reader) error {
	var err error
	if err = util.ReadUint32(r, &m.response.Index); err != nil {
		return err
	}
	if m.response.Response.SessionID, err = util.ReadBytes16(r); err != nil {
		return err
	}
	if err = util.ReadUint32(r, &m.response.Response.Index); err != nil {
		return err
	}
	if err = util.ReadBoolByte(r, &m.response.Response.Approved); err != nil {
		return err
	}
	if m.response.Response.Signature, err = util.ReadBytes16(r); err != nil {
		return err
	}
	return nil
}
func (m *rabinResponseMsg) fromBytes(buf []byte) error {
	m.response = &rabin_dkg.Response{
		Response: &rabin_vss.Response{},
	}
	rdr := bytes.NewReader(buf)
	return m.Read(rdr)
}

//
//
//
type rabinJustificationMsg struct {
	group         kyber.Group // Just for un-marshaling.
	justification *rabin_dkg.Justification
}

func (m *rabinJustificationMsg) MsgType() byte {
	return rabinJustificationMsgType
}
func (m *rabinJustificationMsg) Write(w io.Writer) error {
	var err error
	if err = util.WriteBoolByte(w, m.justification == nil); err != nil {
		return err
	}
	if m.justification != nil {
		if err = util.WriteUint32(w, m.justification.Index); err != nil {
			return err
		}
		if err = util.WriteBoolByte(w, m.justification.Justification == nil); err != nil {
			return err
		}
		if m.justification.Justification != nil {
			// type Justification struct {
			// 	// SessionID related to the current run of the protocol
			// 	SessionID []byte
			// 	// Index of the verifier who issued the Complaint,i.e. index of this Deal
			// 	Index uint32
			// 	// Deal in cleartext
			// 	Deal *Deal
			// 	// Signature over the whole packet
			// 	Signature []byte
			// }
			if err = util.WriteBytes16(w, m.justification.Justification.SessionID); err != nil {
				return err
			}
			if err = util.WriteUint32(w, m.justification.Justification.Index); err != nil {
				return err
			}
			if err = util.WriteBoolByte(w, m.justification.Justification.Deal == nil); err != nil {
				return err
			}
			if m.justification.Justification.Deal != nil {
				// type Deal struct {
				// 	// Unique session identifier for this protocol run
				// 	SessionID []byte
				// 	// Private share generated by the dealer
				// 	SecShare *share.PriShare
				// 	// Random share generated by the dealer
				// 	RndShare *share.PriShare
				// 	// Threshold used for this secret sharing run
				// 	T uint32
				// 	// Commitments are the coefficients used to verify the shares against
				// 	Commitments []kyber.Point
				// }
				if err = util.WriteBytes16(w, m.justification.Justification.Deal.SessionID); err != nil {
					return err
				}
				if err = writePriShare(w, m.justification.Justification.Deal.SecShare); err != nil {
					return err
				}
				if err = writePriShare(w, m.justification.Justification.Deal.RndShare); err != nil {
					return err
				}
				if err = util.WriteUint32(w, m.justification.Justification.Deal.T); err != nil {
					return err
				}
				if err = util.WriteUint32(w, uint32(len(m.justification.Justification.Deal.Commitments))); err != nil {
					return err
				}
				for i := range m.justification.Justification.Deal.Commitments {
					if err = writeMarshaled(w, m.justification.Justification.Deal.Commitments[i]); err != nil {
						return err
					}
				}
			}
			if err = util.WriteBytes16(w, m.justification.Justification.Signature); err != nil {
				return err
			}
		}
	}
	return nil
}
func (m *rabinJustificationMsg) Read(r io.Reader) error {
	var err error
	var isNil bool
	if err = util.ReadBoolByte(r, &isNil); err != nil {
		return err
	}
	if isNil {
		m.justification = nil
		return nil
	}
	m.justification = &rabin_dkg.Justification{}
	if err = util.ReadUint32(r, &m.justification.Index); err != nil {
		return err
	}
	{ // m.justification.Justification
		// type Justification struct {
		// 	// SessionID related to the current run of the protocol
		// 	SessionID []byte
		// 	// Index of the verifier who issued the Complaint,i.e. index of this Deal
		// 	Index uint32
		// 	// Deal in cleartext
		// 	Deal *Deal
		// 	// Signature over the whole packet
		// 	Signature []byte
		// }
		if err = util.ReadBoolByte(r, &isNil); err != nil {
			return err
		}
		if isNil {
			m.justification.Justification = nil
			return nil
		}
		m.justification.Justification = &rabin_vss.Justification{}
		if m.justification.Justification.SessionID, err = util.ReadBytes16(r); err != nil {
			return err
		}
		if err = util.ReadUint32(r, &m.justification.Justification.Index); err != nil {
			return err
		}
		{ // m.justification.Justification.Deal
			m.justification.Justification.Deal = nil
			if err = util.ReadBoolByte(r, &isNil); err != nil {
				return err
			}
			if !isNil {
				m.justification.Justification.Deal = &rabin_vss.Deal{}
				// type Deal struct {
				// 	// Unique session identifier for this protocol run
				// 	SessionID []byte
				// 	// Private share generated by the dealer
				// 	SecShare *share.PriShare
				// 	// Random share generated by the dealer
				// 	RndShare *share.PriShare
				// 	// Threshold used for this secret sharing run
				// 	T uint32
				// 	// Commitments are the coefficients used to verify the shares against
				// 	Commitments []kyber.Point
				// }
				if m.justification.Justification.Deal.SessionID, err = util.ReadBytes16(r); err != nil {
					return err
				}
				if err = readPriShare(r, &m.justification.Justification.Deal.SecShare); err != nil {
					return err
				}
				if err = readPriShare(r, &m.justification.Justification.Deal.RndShare); err != nil {
					return err
				}
				if err = util.ReadUint32(r, &m.justification.Justification.Deal.T); err != nil {
					return err
				}
				var commitmentCount uint32
				if err = util.ReadUint32(r, &commitmentCount); err != nil {
					return err
				}
				m.justification.Justification.Deal.Commitments = make([]kyber.Point, int(commitmentCount))
				for i := range m.justification.Justification.Deal.Commitments {
					m.justification.Justification.Deal.Commitments[i] = m.group.Point()
					if err = readMarshaled(r, m.justification.Justification.Deal.Commitments[i]); err != nil {
						return err
					}
				}
			}
		}
		if m.justification.Justification.Signature, err = util.ReadBytes16(r); err != nil {
			return err
		}
	}
	return nil
}
func (m *rabinJustificationMsg) fromBytes(buf []byte, group kyber.Group) error {
	m.group = group
	rdr := bytes.NewReader(buf)
	return m.Read(rdr)
}

//
//
//
type rabinSecretCommitsMsg struct {
	group         kyber.Group // Just for un-marshaling.
	secretCommits *rabin_dkg.SecretCommits
}

func (m *rabinSecretCommitsMsg) MsgType() byte {
	return rabinSecretCommitsMsgType
}
func (m *rabinSecretCommitsMsg) Write(w io.Writer) error {
	// var err error
	// type SecretCommits struct {
	// 	// Index of the Dealer in the list of participants
	// 	Index uint32
	// 	// Commitments generated by the Dealer
	// 	Commitments []kyber.Point
	// 	// SessionID generated by the Dealer tied to the Deal
	// 	SessionID []byte
	// 	// Signature from the Dealer
	// 	Signature []byte
	// }

	return nil // TODO
}
func (m *rabinSecretCommitsMsg) Read(r io.Reader) error {
	// var err error
	return nil // TODO
}
func (m *rabinSecretCommitsMsg) fromBytes(buf []byte, group kyber.Group) error {
	m.group = group
	rdr := bytes.NewReader(buf)
	return m.Read(rdr)
}

//
//	This works for kyber.Point, kyber.Scalar.
//
func writeMarshaled(w io.Writer, val encoding.BinaryMarshaler) error {
	var err error
	var bin []byte
	if bin, err = val.MarshalBinary(); err != nil {
		return err
	}
	if err = util.WriteBytes16(w, bin); err != nil {
		return err
	}
	return nil
}
func readMarshaled(r io.Reader, val encoding.BinaryUnmarshaler) error {
	var err error
	var bin []byte
	if bin, err = util.ReadBytes16(r); err != nil {
		return err
	}
	if err = val.UnmarshalBinary(bin); err != nil {
		return err
	}
	return nil
}

//
// type PriShare struct {
// 	I int          // Index of the private share
// 	V kyber.Scalar // Value of the private share
// }
//
func writePriShare(w io.Writer, val *share.PriShare) error {
	var err error
	if err = util.WriteBoolByte(w, val == nil); err != nil {
		return err
	}
	if val == nil {
		return nil
	}
	if err = util.WriteUint32(w, uint32(val.I)); err != nil {
		return err
	}
	if err = writeMarshaled(w, val.V); err != nil {
		return err
	}
	return nil
}
func readPriShare(r io.Reader, val **share.PriShare) error {
	var err error
	var valNil bool
	if err = util.ReadBoolByte(r, &valNil); err != nil {
		return err
	}
	if valNil {
		*val = nil
	}
	var i uint32
	if err = util.ReadUint32(r, &i); err != nil {
		return err
	}
	(*val).I = int(i)
	if err = readMarshaled(r, (*val).V); err != nil {
		return err
	}
	return nil
}
